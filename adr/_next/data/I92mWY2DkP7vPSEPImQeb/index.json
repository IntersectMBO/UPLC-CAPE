{"pageProps":{"projectName":"UPLC-CAPE","adrs":[{"slug":"0003-use-multi-view-approach-for-benchmark-scenarios","package":null,"title":"Use Multi-View Approach for Benchmark Scenario Specification","status":"accepted","creationDate":"2025-07-21T11:09:15.000Z","publicationDate":"2025-01-22T22:59:59.000Z"},{"slug":"0004-recommend-nix-integration-for-compiler-contributions","package":null,"title":"Recommend Nix Integration for Compiler Contributions","status":"accepted","creationDate":"2025-07-21T11:09:15.000Z","publicationDate":"2025-07-18T21:59:59.000Z"},{"slug":"0001-record-architecture-decisions","package":null,"title":"1. Record architecture decisions","status":"accepted","creationDate":"2025-07-21T11:09:15.000Z","publicationDate":null},{"slug":"0002-use-log4brains-for-adr-management","package":null,"title":"2. Use Log4brains for ADR management","status":"accepted","creationDate":"2025-07-21T11:09:15.000Z","publicationDate":null},{"slug":"0005-custom-builtindata-text-encoding-for-test-cases","package":null,"title":"Custom BuiltinData Text Encoding for Test Cases","status":"accepted","creationDate":"2025-08-20T18:21:16.000Z","publicationDate":"2025-08-20T21:59:59.000Z"},{"slug":"20250826-structural-address-format-for-scriptcontext-test-cases","package":null,"title":"Structural Address Format for ScriptContext Test Cases","status":"accepted","creationDate":"2025-09-10T12:38:24.000Z","publicationDate":"2025-08-26T21:59:59.000Z"},{"slug":"20251006-baseopen-mode-system-with-submission-slugs","package":null,"title":"Base/Open Mode System with Submission Slugs","status":"superseded","creationDate":"2025-10-06T15:04:40.000Z","publicationDate":"2025-10-06T21:59:59.000Z"},{"slug":"20251009-scenario-based-approach-replacing-mode-system","package":null,"title":"Scenario-Based Approach: Replacing Mode System with Dedicated Scenarios","status":"accepted","creationDate":"2025-10-09T14:44:46.000Z","publicationDate":"2025-10-09T21:59:59.000Z"},{"slug":"20251017-uplc-pretty-printing-integration","package":null,"title":"UPLC Pretty-Printing Integration","status":"accepted","creationDate":"2025-10-17T20:57:05.000Z","publicationDate":"2025-10-17T21:59:59.000Z"},{"slug":"20251022-pr-preview-deployment-to-github-pages","package":null,"title":"PR Preview Deployment to GitHub Pages","status":"accepted","creationDate":"2025-10-22T19:30:38.000Z","publicationDate":"2025-10-22T21:59:59.000Z"}],"markdown":"# UPLC-CAPE Architecture Knowledge Base\n\n**Comparative Artifact Performance Evaluation for UPLC**\n\nWelcome to the architectural documentation for UPLC-CAPE, a standardized framework for benchmarking the on-chain performance of programs produced by various compilers in the Cardano smart contract ecosystem.\n\n## About This Project\n\nUPLC-CAPE addresses a critical need in the Cardano ecosystem: the lack of standardized performance comparison tools for compiler-generated UPLC (Untyped Plutus Core) code. This framework enables compiler authors to measure and compare the efficiency of their generated artifacts through standardized benchmark scenarios.\n\n### Key Goals\n\n- **Standardized Benchmarking**: Provide consistent metrics including CPU units, memory units, script size, and term size\n- **Community Resource**: Independent framework serving all compiler teams (Plinth, Aiken, Plutarch, etc.)\n- **Reproducible Results**: Comprehensive metadata ensures deterministic and reproducible benchmarks\n- **Performance Insights**: Help identify optimization opportunities and quantify performance improvements\n\n### Framework Focus\n\nThis framework benchmarks the **performance of compiled artifacts** (script efficiency, execution costs) rather than the compilation process itself (compilation speed, compiler memory usage).\n\n## Benchmark Scenarios\n\nThe framework includes both synthetic and real-world smart contract scenarios:\n\n- **Synthetic Benchmarks**: Fibonacci sequences, recursive algorithms\n- **Real-World Contracts**: Two-party escrow, streaming payments, DAO voting, time-locked staking\n\nEach scenario provides standardized specifications that compiler teams can implement in their respective languages and frameworks.\n\n## Architecture Decision Records\n\nThis knowledge base documents the architectural and design decisions that shape UPLC-CAPE. These ADRs provide context for contributors and maintainers about why certain approaches were chosen.\n\n### ADR Usage Cheatsheet\n\nQuick reference for managing ADRs in this project:\n\n```bash\n# Create a new architectural decision record\nadr new \"Your Decision Title\"\n\n# Preview all ADRs in your browser (recommended for review)\nadr preview\n\n# Build static documentation site for deployment\nadr build\n\n# Show all available commands and options\nadr help\n```\n\n**Single letter shortcuts:** `adr n` (new), `adr p` (preview), `adr b` (build), `adr h` (help)\n\n### ADR Workflow\n\n1. **Research**: Review existing ADRs to understand current architecture\n2. **Create**: Use `adr new \"Title\"` when making significant decisions\n3. **Document**: Fill out Context, Decision, and Consequences sections\n4. **Review**: Use `adr preview` to review your ADR\n5. **Commit**: Include ADR with related implementation changes\n\n## Getting Started\n\nTo contribute to this project:\n\n1. Set up the development environment with `nix develop`\n2. Review existing ADRs to understand architectural context\n3. Follow the established patterns documented in the ADRs\n4. Create ADRs for significant architectural changes\n\n---\n\n_This knowledge base is powered by [Log4brains](https://github.com/thomvaill/log4brains) and managed through Architecture Decision Records._\n","l4bVersion":"1.1.0"},"__N_SSG":true}