{"pageProps":{"projectName":"UPLC-CAPE","currentAdr":{"slug":"0003-use-multi-view-approach-for-benchmark-scenarios","package":null,"title":"Use Multi-View Approach for Benchmark Scenario Specification","status":"accepted","supersededBy":null,"tags":["specification","documentation","benchmarks","architecture"],"deciders":[],"body":{"enhancedMdx":"\nTechnical Story: Refactor the monolithic fibonacci benchmark template by extracting individual files for different view types (state machine, behavioral scenarios, implementation logic).\n\n## Context and Problem Statement\n\nThe initial fibonacci benchmark scenario was specified as a single monolithic document that mixed different types of specification concerns: lifecycle visualization, behavioral test cases, and algorithmic implementation details. This approach created several issues:\n\n1. **Cognitive overload**: Developers had to parse through different types of information to find what they needed\n2. **Maintenance complexity**: Changes to one aspect (e.g., test scenarios) required editing a large document containing unrelated concerns\n3. **Poor reusability**: Different stakeholders needed different views but had to consume the entire specification\n4. **Inconsistent abstraction levels**: The document mixed high-level state transitions with low-level implementation details\n\nHow can we structure benchmark scenario specifications to be more maintainable, consumable, and aligned with best practices for smart contract specification?\n\n## Decision Drivers\n\n- Need for clear separation of concerns in specification documents\n- Research findings advocating for multi-view specification approaches for smart contracts\n- Desire to make scenarios argument-agnostic and reusable across different test cases\n- Goal to improve maintainability and reduce cognitive load for different stakeholder groups\n- Alignment with established software engineering practices for specification documentation\n\n## Considered Options\n\n1. **Single monolithic document** (current approach)\n2. **Multi-view approach with three distinct views**\n3. **Fully formal specification using mathematical notation**\n4. **Code-first approach with minimal documentation**\n\n## Decision Outcome\n\nChosen option: \"Multi-view approach with three distinct views\", because it directly addresses the identified problems while following research-backed best practices for smart contract specification.\n\n### Positive Consequences\n\n- **Improved maintainability**: Each view can be updated independently without affecting others\n- **Better stakeholder alignment**: Different roles can focus on their relevant view (auditors on behavioral scenarios, implementers on logic view, etc.)\n- **Enhanced reusability**: Views are argument-agnostic and can be applied to different test cases\n- **Clearer documentation structure**: Each view has a specific purpose and abstraction level\n- **Reduced cognitive load**: Stakeholders can consume only the information relevant to their needs\n\n### Negative Consequences\n\n- **Increased file count**: Three files instead of one per scenario\n- **Cross-reference complexity**: Need to maintain consistency across multiple views\n- **Initial learning curve**: Contributors need to understand the multi-view approach\n\n## Pros and Cons of the Options\n\n### Single monolithic document\n\nCurrent approach where all specification aspects are in one file.\n\n- Good, because simple file structure with everything in one place\n- Good, because no cross-reference management needed\n- Bad, because creates cognitive overload for readers\n- Bad, because difficult to maintain as scenarios grow in complexity\n- Bad, because mixes different abstraction levels inappropriately\n\n### Multi-view approach with three distinct views\n\nThree separate files: state machine view, behavioral scenarios view, and implementation logic view.\n\n- Good, because aligns with established specification practices for smart contract development\n- Good, because provides clear separation of concerns\n- Good, because enables stakeholder-specific consumption\n- Good, because improves maintainability through modular structure\n- Good, because makes scenarios argument-agnostic and more reusable\n- Bad, because increases file count and cross-reference complexity\n- Bad, because requires initial learning investment for contributors\n\n### Fully formal specification using mathematical notation\n\nMathematical specification using formal methods notation.\n\n- Good, because provides unambiguous specification\n- Good, because enables formal verification\n- Bad, because requires specialized knowledge to read and write\n- Bad, because not accessible to most smart contract developers\n- Bad, because overkill for benchmark scenario specification\n\n### Code-first approach with minimal documentation\n\nMinimal documentation with primary specification in reference implementations.\n\n- Good, because executable specification that can't drift from implementation\n- Good, because familiar to developers\n- Bad, because ties specification to specific programming languages\n- Bad, because makes cross-compiler comparison more difficult\n- Bad, because reduces accessibility for non-implementers (auditors, stakeholders)\n\n## Implementation Details\n\nThe multi-view approach consists of three distinct files per scenario:\n\n### 1. State Machine View (`*-state-machine.md`)\n\n- **Purpose**: High-level lifecycle visualization\n- **Content**: Mermaid state diagrams embedded in markdown, state descriptions, transition conditions\n- **Audience**: All stakeholders seeking high-level understanding\n\n### 2. Behavioral Scenarios View (`*-behavioral-scenarios.md`)\n\n- **Purpose**: Concrete test cases and expected outcomes\n- **Content**: Gherkin scenarios covering happy paths and edge cases\n- **Audience**: Testers, auditors, quality assurance\n\n### 3. Implementation Logic View (`*-implementation-logic.md`)\n\n- **Purpose**: Algorithmic specification for implementers\n- **Content**: Language-agnostic pseudocode, complexity analysis, algorithmic approaches\n- **Audience**: Compiler authors, implementers\n\nAll views are kept argument-agnostic (no hardcoded values like \"fibonacci(25)\") to maximize reusability across different test cases.\n\n## Links\n\n- See [Fibonacci Scenario](../../scenarios/fibonacci.md) for the first implementation of this approach\n"},"creationDate":"2025-07-21T11:09:15.000Z","lastEditDate":"2025-08-13T15:12:51.000Z","lastEditAuthor":"Yura Lazarev","publicationDate":"2025-01-22T22:59:59.000Z","file":{"relativePath":"doc/adr/0003-use-multi-view-approach-for-benchmark-scenarios.md","absolutePath":"/home/runner/work/UPLC-CAPE/UPLC-CAPE/doc/adr/0003-use-multi-view-approach-for-benchmark-scenarios.md"},"repository":{"provider":"github","viewUrl":"https://github.com/IntersectMBO/UPLC-CAPE/blob/master/doc/adr/0003-use-multi-view-approach-for-benchmark-scenarios.md"}},"l4bVersion":"1.1.0"},"__N_SSG":true}