{"pageProps":{"projectName":"UPLC-CAPE","currentAdr":{"slug":"20250826-structural-address-format-for-scriptcontext-test-cases","package":null,"title":"Structural Address Format for ScriptContext Test Cases","status":"accepted","supersededBy":null,"tags":["testing","scriptcontext","address-format","schema","json"],"deciders":[],"body":{"enhancedMdx":"\nTechnical Story: Introduce structural JSON address format for comprehensive ScriptContext testing in cape-tests.json files.\n\n## Context and Problem Statement\n\nThe UPLC-CAPE test framework needed a robust way to specify addresses in ScriptContext test cases for comprehensive smart contract validation. Test cases require the ability to specify both script addresses (for contract-to-contract interactions) and public key addresses (for user interactions) with proper type discrimination and schema validation.\n\nHow should we specify addresses in cape-tests.json files to provide clear type safety, proper validation, and explicit address information for comprehensive ScriptContext testing?\n\n## Decision Drivers\n\n- **Type Safety**: Clear discrimination between script and pubkey addresses\n- **Schema Validation**: Proper JSON schema support with structural validation\n- **Explicit Specification**: All address information explicitly specified\n- **Maintainability**: Easy to read, write, and validate test specifications\n- **Cardano Compatibility**: Align with Cardano address model (script vs pubkey)\n- **Reference Support**: Support for reusable address definitions\n\n## Considered Options\n\n- **Simple string format**: Basic string representation with minimal structure\n- **Structural JSON format**: Use discriminated union with explicit type and hash fields\n- **Nested object approach**: Complex nested structure with multiple address components\n\n## Decision Outcome\n\nChosen option: **Structural JSON format**, because it provides clear type discrimination, enables proper schema validation, supports reference resolution, and makes test specifications explicit and maintainable.\n\n### Address Format Specification\n\n**Script Address:**\n\n```json\n{\n  \"type\": \"script\",\n  \"script_hash\": \"1111111111111111111111111111111111111111111111111111111111\"\n}\n```\n\n**Public Key Address:**\n\n```json\n{\n  \"type\": \"pubkey\",\n  \"pubkey_hash\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n}\n```\n\n**Reference Support:**\n\n```json\n{\n  \"type\": \"pubkey\",\n  \"pubkey_hash\": \"@buyer_pubkey\"\n}\n```\n\n### JSON Schema Definition\n\n```json\n\"address_spec\": {\n  \"type\": \"object\",\n  \"discriminator\": {\n    \"propertyName\": \"type\"\n  },\n  \"oneOf\": [\n    {\n      \"type\": \"object\",\n      \"properties\": {\n        \"type\": { \"const\": \"script\" },\n        \"script_hash\": {\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{56}$\"\n        }\n      },\n      \"required\": [\"type\", \"script_hash\"]\n    },\n    {\n      \"type\": \"object\",\n      \"properties\": {\n        \"type\": { \"const\": \"pubkey\" },\n        \"pubkey_hash\": {\n          \"type\": \"string\",\n          \"description\": \"64-character hex string or @reference\"\n        }\n      },\n      \"required\": [\"type\", \"pubkey_hash\"]\n    }\n  ]\n}\n```\n\n### Haskell Implementation\n\n```haskell\ndata AddressSpec\n  = ScriptAddressSpec Text\n  | PubkeyAddressSpec Text\n  deriving (Eq, Show)\n\ninstance FromJSON AddressSpec where\n  parseJSON = withObject \"AddressSpec\" \\o -> do\n    addrType :: Text <- o .: \"type\"\n    case addrType of\n      \"script\" -> ScriptAddressSpec <$> o .: \"script_hash\"\n      \"pubkey\" -> PubkeyAddressSpec <$> o .: \"pubkey_hash\"\n      _ -> fail $ \"Unknown address type: \" <> toString addrType\n\nparseAddressSpec :: Map Text DataStructureEntry -> AddressSpec -> IO V3.Address\nparseAddressSpec dataStructures addressSpec = case addressSpec of\n  ScriptAddressSpec scriptHashText ->\n    pure $ V3.Address\n      (V3.ScriptCredential (V3.ScriptHash (fromString (toString scriptHashText))))\n      Nothing\n  PubkeyAddressSpec pubkeyHashText -> do\n    resolvedHash <- resolveReference dataStructures pubkeyHashText\n    pure $ V3.Address\n      (V3.PubKeyCredential (V3.PubKeyHash (fromString (toString resolvedHash))))\n      Nothing\n```\n\n### Positive Consequences\n\n- **Clear Type Safety**: Explicit discrimination between script and pubkey addresses\n- **Schema Validation**: Comprehensive JSON schema validation with proper error messages\n- **Self-Documenting**: Test specifications are clear about address types\n- **Reference Support**: Reusable address definitions via @reference resolution\n- **Runtime Safety**: Proper hex string conversion using OverloadedStrings\n- **Extensibility**: Easy to add new address types or fields in the future\n\n### Negative Consequences\n\n- **Verbosity**: More verbose than simple string representations\n- **Learning Curve**: Test authors need to understand the structural format\n\n## Implementation Details\n\n### Files Modified\n\n1. **lib/Cape/Tests.hs**: Core parsing logic with new AddressSpec data type\n2. **schemas/cape-tests.schema.json**: JSON schema with structural address format\n3. **scenarios/two-party-escrow/cape-tests.json**: Example usage in test specifications\n\n### Runtime Conversion\n\nUses OverloadedStrings extension for runtime hex string conversion:\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\n-- Converts hex string to BuiltinByteString at runtime\nscriptHash = fromString (toString scriptHashText) :: BuiltinByteString\n```\n\n## Examples\n\n### Script Address Usage\n\n```json\n{\n  \"op\": \"add_output_utxo\",\n  \"address\": {\n    \"type\": \"script\",\n    \"script_hash\": \"1111111111111111111111111111111111111111111111111111111111\"\n  },\n  \"lovelace\": 75000000\n}\n```\n\n### Public Key Address with Reference\n\n```json\n{\n  \"op\": \"add_output_utxo\",\n  \"address\": {\n    \"type\": \"pubkey\",\n    \"pubkey_hash\": \"@impostor_pubkey\"\n  },\n  \"lovelace\": 75000000\n}\n```\n\n### Data Structure Definitions\n\n```json\n{\n  \"data_structures\": {\n    \"buyer_pubkey\": {\n      \"type\": \"builtin_data\",\n      \"value\": \"#aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n    }\n  }\n}\n```\n\n## Links\n\n- Related to comprehensive ScriptContext testing capabilities\n- Builds on custom BuiltinData text encoding (ADR-0005)\n- Enables proper schema validation for complex test specifications\n"},"creationDate":"2025-09-10T12:38:24.000Z","lastEditDate":"2025-09-10T12:38:24.000Z","lastEditAuthor":"Yura Lazaryev","publicationDate":"2025-08-26T21:59:59.000Z","file":{"relativePath":"doc/adr/20250826-structural-address-format-for-scriptcontext-test-cases.md","absolutePath":"/home/runner/work/UPLC-CAPE/UPLC-CAPE/doc/adr/20250826-structural-address-format-for-scriptcontext-test-cases.md"},"repository":{"provider":"github","viewUrl":"https://github.com/IntersectMBO/UPLC-CAPE/blob/master/doc/adr/20250826-structural-address-format-for-scriptcontext-test-cases.md"}},"l4bVersion":"1.1.0"},"__N_SSG":true}