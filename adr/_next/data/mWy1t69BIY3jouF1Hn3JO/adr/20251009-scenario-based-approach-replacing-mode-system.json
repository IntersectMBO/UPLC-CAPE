{"pageProps":{"projectName":"UPLC-CAPE","currentAdr":{"slug":"20251009-scenario-based-approach-replacing-mode-system","package":null,"title":"Scenario-Based Approach: Replacing Mode System with Dedicated Scenarios","status":"accepted","supersededBy":null,"tags":["benchmarking","submissions","scenarios","simplification"],"deciders":[],"body":{"enhancedMdx":"\n- Supersedes: <AdrLink slug=\"20251006-baseopen-mode-system-with-submission-slugs\" status=\"superseded\" title=\"Base/Open Mode System with Submission Slugs\" customLabel=\"20251006-baseopen-mode-system-with-submission-slugs.md\" />\n\nTechnical Story: [Issue #59](https://github.com/IntersectMBO/UPLC-CAPE/issues/59), [PR #60](https://github.com/IntersectMBO/UPLC-CAPE/pull/60)\n\n## Context and Problem Statement\n\nThe base/open mode system (implemented in PR #60) introduced a `mode` attribute and `slug` field to distinguish between prescribed algorithm benchmarks (\"base\" mode) and open optimization benchmarks (\"open\" mode) within the same scenario. After implementation and community feedback, several issues were identified:\n\n**Problems with the Mode System:**\n\n1. **Unnecessary Complexity**: The mode attribute added an extra dimension to track across metadata, CLI flags, directory naming, and reporting\n2. **Verbose Documentation**: Scenario docs grew to 221-230 lines, including extensive mode-specific guidance that overwhelmed implementors\n3. **Confusing Reporting**: HTML reports separated base/open modes within the same scenario, creating cognitive overhead\n4. **Unclear Semantics**: The concept of \"modes\" within a single scenario was less intuitive than having separate scenarios\n\n**Feedback Summary:**\n\n- \"The 'mode' as implemented adds too much complexity\"\n- \"Scenario descriptions are too verbose for implementors\"\n- \"Common submission instructions should be extracted\"\n- \"Instead of mode=base, we should have dedicated scenarios like `fibonacci_naive_recursion`\"\n\n**Question**: How can we achieve the same goal (prescribed vs. open optimization benchmarks) with less complexity and better clarity?\n\n## Decision Drivers\n\n- Reduce cognitive overhead for users (implementors and report readers)\n- Simplify metadata schema and CLI interface\n- Make scenario intent immediately clear from directory structure\n- Extract common guidance to avoid duplication\n- Maintain backward compatibility path for existing submissions\n- Enable future growth with additional constraint variations\n\n## Considered Options\n\n1. **Keep Mode System** - Retain base/open modes with incremental improvements\n2. **Scenario-Based Approach** - Create dedicated scenarios for prescribed algorithms\n3. **Tag-Based System** - Use metadata tags instead of mode field\n4. **Hybrid Approach** - Combine scenarios with optional mode flags\n\n## Decision Outcome\n\nChosen option: **\"Scenario-Based Approach\"**, because it:\n\n- Eliminates the mode attribute entirely (simpler metadata and CLI)\n- Makes intent immediately clear from scenario name (`fibonacci` vs `fibonacci_naive_recursion`)\n- Reduces scenario documentation by 70-80% (from ~220 lines to ~40-60 lines)\n- Enables natural growth (can add `fibonacci_iterative`, `fibonacci_memoized`, etc. as separate scenarios)\n- Simplifies HTML reports (back to simple scenario-based organization)\n- Follows principle of \"make the common case simple\" (most users want either prescribed OR open, rarely both)\n\n### Implementation Overview\n\n**New Scenario Structure:**\n\n```\nscenarios/\n├── fibonacci/                    # Open optimization (any approach)\n├── fibonacci_naive_recursion/    # Prescribed naive recursive algorithm\n├── factorial/                    # Open optimization (any approach)\n├── factorial_naive_recursion/    # Prescribed naive recursive algorithm\n└── two_party_escrow/             # Open optimization only\n```\n\n**Submission Naming (Simplified):**\n\n```\n# Before (with mode system):\nsubmissions/fibonacci/Plinth_1.45.0.0_Unisay_base/\nsubmissions/fibonacci/Plinth_1.45.0.0_Unisay_open/\nsubmissions/fibonacci/Plutarch_1.11.1_SeungheonOh_open_pfix/\n\n# After (scenario-based):\nsubmissions/fibonacci_naive_recursion/Plinth_1.45.0.0_Unisay/\nsubmissions/fibonacci/Plinth_1.45.0.0_Unisay/\nsubmissions/fibonacci/Plutarch_1.11.1_SeungheonOh_pfix/\n```\n\n**Streamlined Scenario Documentation:**\n\nScenario docs now contain ONLY (~40-60 lines):\n\n- **Overview**: What this benchmark tests\n- **Exact Task**: What to implement\n- **Algorithm Specification**: Prescribed algorithm (for `_naive_recursion` variants) OR implementation freedom (for open scenarios)\n- **Technical Constraints**: Plutus Core version, budget limits, etc.\n- **Link to Common Guide**: Reference to `doc/submission-guide.md` for metrics, acceptance criteria, validation\n\n**Extracted to `doc/submission-guide.md`:**\n\n- General submission workflow\n- Metrics explanation (CPU, memory, script size, term size)\n- Acceptance criteria (correctness, budget compliance, determinism)\n- Validation checklist and commands\n- File requirements and templates\n\n**Metadata Schema Simplification:**\n\n```json\n// Removed fields:\n{\n  \"submission\": {\n    \"mode\": \"base|open\", // REMOVED\n    \"slug\": \"memoized\" // REMOVED\n  }\n}\n\n// Simplified to just scenario-based organization\n// Variant suffixes optional in directory name only\n```\n\n**CLI Simplification:**\n\n```bash\n# Before (with mode):\ncape submission new fibonacci Compiler 1.0 handle --mode base\ncape submission new fibonacci Compiler 1.0 handle --mode open --slug memoized\ncape submission list fibonacci --mode base\ncape submission report fibonacci --mode open\n\n# After (scenario-based):\ncape submission new fibonacci_naive_recursion Compiler 1.0 handle\ncape submission new fibonacci Compiler 1.0 handle\ncape submission new fibonacci Compiler 1.0 handle_memoized  # variant in name\ncape submission list fibonacci_naive_recursion\ncape submission report fibonacci\n```\n\n**HTML Report Restoration:**\n\n- Return to pre-mode format: single table per scenario\n- `fibonacci` and `fibonacci_naive_recursion` are independent scenarios with separate reports\n- No mode filtering or grouping logic\n- Simpler, more predictable navigation\n\n### Positive Consequences\n\n- **70-80% reduction in scenario doc length**: From 221-230 lines to 40-60 lines\n- **Eliminated CLI complexity**: No `--mode` or `--slug` flags to remember\n- **Clearer intent**: Scenario name immediately indicates constraints\n- **Simpler metadata**: Fewer required fields, less validation complexity\n- **Better organization**: Common guidance in single location (`doc/submission-guide.md`)\n- **Natural extensibility**: Easy to add `fibonacci_iterative`, `factorial_tail_recursive`, etc.\n- **Simpler reports**: Back to straightforward scenario-based tables\n- **Lower maintenance**: Less code to maintain (no mode filtering throughout)\n\n### Negative Consequences\n\n- **Breaking change**: Requires migration of existing submissions\n- **More scenario directories**: `fibonacci_naive_recursion` adds directory (but clearer)\n- **Potential proliferation**: Could lead to many scenario variants (but this is actually a feature for fine-grained benchmarking)\n- **Migration effort**: All existing metadata.json files must be updated\n\n## Pros and Cons of the Options\n\n### Option 1: Keep Mode System\n\n- Good, because no migration needed\n- Good, because mode concept is familiar from compilation contexts\n- Bad, because adds complexity to metadata, CLI, and reports\n- Bad, because scenario docs remain too long (220+ lines)\n- Bad, because mode semantics less clear than scenario names\n- Bad, because feedback indicates it's \"too much complexity\"\n\n### Option 2: Scenario-Based Approach (CHOSEN)\n\n- Good, because scenario name immediately indicates intent\n- Good, because massive documentation simplification (70-80% reduction)\n- Good, because eliminates mode attribute entirely\n- Good, because simpler CLI and metadata schema\n- Good, because enables natural growth (add scenarios as needed)\n- Good, because addresses all feedback points\n- Bad, because requires migration of existing submissions\n- Bad, because creates more top-level scenario directories\n\n### Option 3: Tag-Based System\n\n- Good, because flexible tagging without directory changes\n- Bad, because tags hidden in metadata (less discoverable)\n- Bad, because doesn't solve documentation verbosity\n- Bad, because still requires attribute in metadata\n- Bad, because unclear semantics (what tags mean what?)\n\n### Option 4: Hybrid Approach\n\n- Good, because could combine benefits\n- Bad, because adds even more complexity\n- Bad, because doesn't address core feedback about simplification\n- Bad, because would still have verbose documentation\n\n## Implementation Details\n\n### Scenario Creation\n\nNew scenarios created with prescribed algorithms:\n\n- `scenarios/fibonacci_naive_recursion/` - Naive recursive fibonacci implementation required\n- `scenarios/factorial_naive_recursion/` - Naive recursive factorial implementation required\n\nEach includes:\n\n- Streamlined `.md` spec (~40-60 lines)\n- `cape-tests.json` for verification\n- Same structure as existing scenarios\n\n### Documentation Extraction\n\nCreate `doc/submission-guide.md` containing:\n\n- **Metrics Explanation**: What CPU units, memory units, script size, term size mean\n- **Acceptance Criteria**: Correctness, budget compliance, determinism, self-contained, valid format\n- **Validation Workflow**: Commands to verify and measure submissions\n- **File Requirements**: What files are needed (uplc, metadata.json, metrics.json, README.md)\n- **Templates**: Links to schema and template files\n- **Common Checklist**: Steps all submissions should follow\n\nAll scenario docs link to this guide instead of duplicating content.\n\n### Migration Strategy\n\n**Existing Submissions:**\n\n1. Create new scenario directories:\n   - `submissions/fibonacci_naive_recursion/`\n   - `submissions/factorial_naive_recursion/`\n\n2. Migrate base mode submissions:\n   - `fibonacci/*_base/` → `fibonacci_naive_recursion/*/` (remove `_base` suffix)\n   - `factorial/*_base/` → `factorial_naive_recursion/*/` (remove `_base` suffix)\n\n3. Migrate open mode submissions:\n   - `fibonacci/*_open/` → `fibonacci/*/` (remove `_open` suffix)\n   - `factorial/*_open/` → `factorial/*/` (remove `_open` suffix)\n   - `factorial/*_open_pfix/` → `factorial/*_pfix/` (remove `_open_`, keep variant)\n\n4. Update all `metadata.json` files:\n   - Remove `\"mode\": \"base|open\"` field\n   - Remove `\"slug\": \"...\"` field (if present)\n\n**CLI Updates:**\n\nRemove from all affected scripts:\n\n- `--mode base|open` flag and associated logic\n- `--slug <name>` flag and associated logic\n- Mode-based filtering in list/report/aggregate commands\n- Mode-based directory naming logic\n\n**Schema Updates:**\n\nRemove from `submissions/TEMPLATE/metadata.schema.json`:\n\n- `submission.mode` field (was required)\n- `submission.slug` field (was optional)\n\nUpdate `metadata-template.json` accordingly.\n\n**Report Generation:**\n\nRestore pre-mode report format:\n\n- Remove mode filtering/grouping\n- Each scenario gets its own independent report\n- `fibonacci` and `fibonacci_naive_recursion` treated as separate scenarios\n- Simple scenario-based navigation\n\n### Verification Strategy\n\n**Scenario Compliance:**\n\nFor prescribed scenarios (`_naive_recursion`):\n\n- Community review during PR process\n- Submission README explains algorithm compliance\n- Reviewers verify against scenario specification\n- Honor system with clear guidelines\n\nFor open scenarios:\n\n- No algorithmic constraints\n- Only correctness verification via `cape-tests.json`\n- Variant suffix (e.g., `_memoized`) for documentation only\n\n## Applicability\n\n**When to Use Prescribed Scenarios:**\n\n- Synthetic benchmarks where algorithm can be clearly specified\n- Compiler comparison needs (isolate compiler effectiveness)\n- Educational purposes (demonstrate optimization of specific algorithm)\n\n**When to Use Open Scenarios:**\n\n- Real-world scenarios (complex validators)\n- Optimization showcases (best achievable performance)\n- Exploring different algorithmic approaches\n\n**Growth Pattern:**\n\n- Start with open scenario (e.g., `fibonacci`)\n- Add prescribed variants as needed (e.g., `fibonacci_naive_recursion`, `fibonacci_iterative`)\n- Each scenario is self-contained and independently useful\n\n## Migration Timeline\n\n1. **Phase 1**: Create new scenarios and documentation (fibonacci_naive_recursion, factorial_naive_recursion, submission-guide.md)\n2. **Phase 2**: Remove mode system from CLI and schemas\n3. **Phase 3**: Migrate existing submissions\n4. **Phase 4**: Restore HTML report format\n5. **Phase 5**: Update tests and project documentation\n6. **Phase 6**: Final verification and testing\n\nEstimated total effort: 20-26 hours\n\n## Links\n\n- [GitHub Issue #59](https://github.com/IntersectMBO/UPLC-CAPE/issues/59) - Original feature request for base/open mode system\n- [GitHub PR #60](https://github.com/IntersectMBO/UPLC-CAPE/pull/60) - Implementation of mode system (now superseded)\n- Supersedes: <AdrLink slug=\"20251006-baseopen-mode-system-with-submission-slugs\" status=\"superseded\" title=\"Base/Open Mode System with Submission Slugs\" customLabel=\"ADR 20251006: Base/Open Mode System\" />\n"},"creationDate":"2025-10-09T14:44:46.000Z","lastEditDate":"2025-11-04T11:09:02.000Z","lastEditAuthor":"Yura Lazaryev","publicationDate":"2025-10-09T21:59:59.000Z","file":{"relativePath":"doc/adr/20251009-scenario-based-approach-replacing-mode-system.md","absolutePath":"/home/runner/work/UPLC-CAPE/UPLC-CAPE/doc/adr/20251009-scenario-based-approach-replacing-mode-system.md"},"repository":{"provider":"github","viewUrl":"https://github.com/IntersectMBO/UPLC-CAPE/blob/master/doc/adr/20251009-scenario-based-approach-replacing-mode-system.md"}},"l4bVersion":"1.1.0"},"__N_SSG":true}